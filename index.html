<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>komamj&#39;s 札记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="日常开发的总结与记录">
<meta property="og:type" content="website">
<meta property="og:title" content="komamj&#39;s 札记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="komamj&#39;s 札记">
<meta property="og:description" content="日常开发的总结与记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="komamj">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Flutter">
<meta property="article:tag" content="Agile">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="komamj&#39;s 札记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">komamj&#39;s 札记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">komamj在mobile开发中的一些总结与记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-bloaters" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/17/bloaters/" class="article-date">
  <time datetime="2020-02-17T02:35:22.000Z" itemprop="datePublished">2020-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/17/bloaters/">代码坏味道之膨胀剂</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="膨胀剂"><a href="#膨胀剂" class="headerlink" title="膨胀剂"></a>膨胀剂</h1><blockquote>
<p>代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。</p>
</blockquote>
<img src="/2020/02/17/bloaters/bloaters.png" class="" title="bloaters">

<ul>
<li><a href="#过长方法">过长方法</a></li>
<li><a href="#过大的类">过大的类</a></li>
<li><a href="#基本类型偏执">基本类型偏执</a></li>
<li><a href="#过长参数列">过长参数列</a></li>
<li><a href="#数据泥团">数据泥团</a></li>
</ul>
<h2 id="过长方法"><a href="#过长方法" class="headerlink" title="过长方法"></a>过长方法</h2><blockquote>
<ul>
<li>一个函数含有太多行代码。一般来说，任何函数超过 <strong>10</strong> 行时，你就可以考虑是不是过长了。 </li>
<li>函数中的代码行数原则上不要超过 <strong>100</strong> 行。</li>
</ul>
</blockquote>
<img src="/2020/02/17/bloaters/long-method-01.png" class="" title="long-method-01">

<h3 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h3><p>通常情况下，创建一个新函数的难度要大于添加功能到一个已存在的函数。大部分人都觉得：“我就添加这么两行代码，为此新建一个函数实在是小题大做了。<br>”于是，张三加两行，李四加两行，王五加两行。。。函数日益庞大，最终烂的像一锅浆糊，再也没人能完全看懂了。<br>于是大家就更不敢轻易动这个函数了，只能恶性循环的往其中添加代码。所以，如果你看到一个超过 200 行的函数，通常都是多个程序员东拼西凑出来的。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>一个很好的技巧是：<strong>寻找注释</strong>。添加注释，一般有这么几个原因：代码逻辑较为晦涩或复杂；这段代码功能相对独立；特殊处理。<br>如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。<br>如果函数有一个描述恰当的名字，就不需要去看内部代码究竟是如何实现的。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中。</p>
<img src="/2020/02/17/bloaters/long-method-02.png" class="" title="long-method-02">

<ul>
<li>为了给一个函数瘦身，可以使用 <code>提炼函数(Extract Method)</code>。</li>
<li>如果局部变量和参数干扰提炼函数，可以使用 <code>以查询取代临时变量(Replace Temp with Query)</code>，<code>引入参数对象(Introduce Parameter Object)</code> 或 <code>保持对象完整(Preserve Whole Object)</code> 。</li>
<li>如果前面两条没有帮助，可以通过 <code>以函数对象取代函数(Replace Method with Method Object)</code> 尝试移动整个函数到一个独立的对象中。</li>
<li>条件表达式和循环常常也是提炼的信号。对于条件表达式，可以使用 <code>分解条件表达式(Decompose Conditional)</code> 。至于循环，应该使用 <code>提炼函数(Extract Method)</code> 将循环和其内的代码提炼到独立函数中。</li>
</ul>
<h3 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h3><ul>
<li>在所有类型的面向对象代码中，函数比较短小精悍的类往往生命周期较长。一个函数越长，就越不容易理解和维护。</li>
<li>此外，过长函数中往往含有难以发现的重复代码。</li>
</ul>
<img src="/2020/02/17/bloaters/long-method-03.png" class="" title="long-method-03">

<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>是否像许多人说的那样，增加函数的数量会影响性能？在几乎绝大多数情况下，这种影响是可以忽略不计，所以不用担心。<br>此外，现在有了清晰和易读的代码，在需要的时候，你将更容易找到真正有效的函数来重组代码和提高性能。</p>
<h3 id="重构方法说明"><a href="#重构方法说明" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="提炼函数-Extract-Method"><a href="#提炼函数-Extract-Method" class="headerlink" title="提炼函数(Extract Method)"></a>提炼函数(Extract Method)</h4><p><strong>问题</strong></p>
<p>你有一段代码可以组织在一起。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void printOwing() &#123;</span><br><span class="line">  printBanner();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;print details</span><br><span class="line">  System.out.println(&quot;name: &quot; + name);</span><br><span class="line">  System.out.println(&quot;amount: &quot; + getOutstanding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>移动这段代码到一个新的函数中，使用函数的调用来替代老代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void printOwing() &#123;</span><br><span class="line">  printBanner();</span><br><span class="line">  printDetails(getOutstanding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printDetails(double outstanding) &#123;</span><br><span class="line">  System.out.println(&quot;name: &quot; + name);</span><br><span class="line">  System.out.println(&quot;amount: &quot; + outstanding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="以查询取代临时变量-Replace-Temp-with-Query"><a href="#以查询取代临时变量-Replace-Temp-with-Query" class="headerlink" title="以查询取代临时变量(Replace Temp with Query)"></a>以查询取代临时变量(Replace Temp with Query)</h4><p><strong>问题</strong></p>
<p>将表达式的结果放在局部变量中，然后在代码中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double calculateTotal() &#123;</span><br><span class="line">  double basePrice &#x3D; quantity * itemPrice;</span><br><span class="line">  if (basePrice &gt; 1000) &#123;</span><br><span class="line">    return basePrice * 0.95;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    return basePrice * 0.98;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>将整个表达式移动到一个独立的函数中并返回结果。使用查询函数来替代使用变量。如果需要，可以在其他函数中合并新函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">double calculateTotal() &#123;</span><br><span class="line">  if (basePrice() &gt; 1000) &#123;</span><br><span class="line">    return basePrice() * 0.95;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    return basePrice() * 0.98;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">double basePrice() &#123;</span><br><span class="line">  return quantity * itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引入参数对象-Introduce-Parameter-Object"><a href="#引入参数对象-Introduce-Parameter-Object" class="headerlink" title="引入参数对象(Introduce Parameter Object)"></a>引入参数对象(Introduce Parameter Object)</h4><p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<img src="/2020/02/17/bloaters/introduce-parameter-object-before.png" class="" title="introduce-parameter-object-before">

<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<img src="/2020/02/17/bloaters/introduce-parameter-object-after.png" class="" title="introduce-parameter-object-after">

<h4 id="保持对象完整-Preserve-Whole-Object"><a href="#保持对象完整-Preserve-Whole-Object" class="headerlink" title="保持对象完整(Preserve Whole Object)"></a>保持对象完整(Preserve Whole Object)</h4><p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int low &#x3D; daysTempRange.getLow();</span><br><span class="line">int high &#x3D; daysTempRange.getHigh();</span><br><span class="line">boolean withinPlan &#x3D; plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean withinPlan &#x3D; plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>

<h4 id="以函数对象取代函数-Replace-Method-with-Method-Object"><a href="#以函数对象取代函数-Replace-Method-with-Method-Object" class="headerlink" title="以函数对象取代函数(Replace Method with Method Object)"></a>以函数对象取代函数(Replace Method with Method Object)</h4><p><strong>问题</strong></p>
<p>你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(Extract Method) 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Order &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public double price() &#123;</span><br><span class="line">    double primaryBasePrice;</span><br><span class="line">    double secondaryBasePrice;</span><br><span class="line">    double tertiaryBasePrice;</span><br><span class="line">    &#x2F;&#x2F; long computation.</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Order &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  public double price() &#123;</span><br><span class="line">    return new PriceCalculator(this).compute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PriceCalculator &#123;</span><br><span class="line">  private double primaryBasePrice;</span><br><span class="line">  private double secondaryBasePrice;</span><br><span class="line">  private double tertiaryBasePrice;</span><br><span class="line"></span><br><span class="line">  public PriceCalculator(Order order) &#123;</span><br><span class="line">    &#x2F;&#x2F; copy relevant information from order object.</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public double compute() &#123;</span><br><span class="line">    &#x2F;&#x2F; long computation.</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分解条件表达式-Decompose-Conditional"><a href="#分解条件表达式-Decompose-Conditional" class="headerlink" title="分解条件表达式(Decompose Conditional)"></a>分解条件表达式(Decompose Conditional)</h4><p><strong>问题</strong></p>
<p>你有复杂的条件表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (date.before(SUMMER_START) || date.after(SUMMER_END)) &#123;</span><br><span class="line">  charge &#x3D; quantity * winterRate + winterServiceCharge;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  charge &#x3D; quantity * summerRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>根据条件分支将整个条件表达式分解成几个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (notSummer(date)) &#123;</span><br><span class="line">  charge &#x3D; winterCharge(quantity);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  charge &#x3D; summerCharge(quantity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>程序愈长就愈难理解</li>
<li>函数过长阅读起来也不方便</li>
<li>小函数的价值：解释能力、共享能力、选择能力</li>
</ul>
</blockquote>
<p><strong>Tips：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的函数中。记着，起个好名字！</strong></p>
<h2 id="过大的类"><a href="#过大的类" class="headerlink" title="过大的类"></a>过大的类</h2><blockquote>
<p>一个类含有过多字段、函数、代码行。</p>
</blockquote>


<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>类通常一开始很小，但是随着程序的增长而逐渐膨胀。</p>
<p>类似于过长函数，程序员通常觉得在一个现存类中添加新特性比创建一个新的类要容易。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>设计模式中有一条重要原则：职责单一原则。一个类应该只赋予它一个职责。如果它所承担的职责太多，就该考虑为它减减负。</p>


<ul>
<li>如果过大类中的部分行为可以提炼到一个独立的组件中，可以使用 <code>提炼类(Extract Class)</code>。</li>
<li>如果过大类中的部分行为可以用不同方式实现或使用于特殊场景，可以使用 <code>提炼子类(Extract Subclass)</code>。</li>
<li>如果有必要为客户端提供一组操作和行为，可以使用 <code>提炼接口(Extract Interface)</code>。</li>
<li>如果你的过大类是个 GUI 类，可能需要把数据和行为移到一个独立的领域对象去。你可能需要两边各保留一些重复数据，并保持两边同步。 <code>复制被监视数据(Duplicate Observed Data)</code> 可以告诉你怎么做。</li>
</ul>
<h3 id="收益-1"><a href="#收益-1" class="headerlink" title="收益"></a>收益</h3><ul>
<li>重构过大的类可以使程序员不必记住一个类中大量的属性。</li>
<li>在大多数情况下，分割过大的类可以避免代码和功能的重复。</li>
</ul>


<h3 id="重构方法说明-1"><a href="#重构方法说明-1" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="提炼类-Extract-Class"><a href="#提炼类-Extract-Class" class="headerlink" title="提炼类(Extract Class)"></a>提炼类(Extract Class)</h4><p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<img src="/2020/02/17/bloaters/extract-class-before.png" class="" title="extract-class-before">

<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<img src="/2020/02/17/bloaters/extract-class-after.png" class="" title="extract-class-after">

<h4 id="提炼子类-Extract-Subclass"><a href="#提炼子类-Extract-Subclass" class="headerlink" title="提炼子类(Extract Subclass)"></a>提炼子类(Extract Subclass)</h4><p><strong>问题</strong></p>
<p>一个类中有些特性仅用于特定场景。</p>


<p><strong>解决</strong></p>
<p>创建一个子类，并将用于特殊场景的特性置入其中。</p>


<h4 id="提炼接口-Extract-Interface"><a href="#提炼接口-Extract-Interface" class="headerlink" title="提炼接口(Extract Interface)"></a>提炼接口(Extract Interface)</h4><p><strong>问题</strong></p>
<p>多个客户端使用一个类部分相同的函数。另一个场景是两个类中的部分函数相同。</p>
<img src="/2020/02/17/bloaters/extract-interface-before.png" class="" title="extract-interface-before">

<p><strong>解决</strong></p>
<p>移动相同的部分函数到接口中。</p>
<img src="/2020/02/17/bloaters/extract-interface-after.png" class="" title="extract-interface-after">

<h4 id="复制被监视数据-Duplicate-Observed-Data"><a href="#复制被监视数据-Duplicate-Observed-Data" class="headerlink" title="复制被监视数据(Duplicate Observed Data)"></a>复制被监视数据(Duplicate Observed Data)</h4><p><strong>问题</strong></p>
<p>如果存储在类中的数据是负责 GUI 的。</p>
<img src="/2020/02/17/bloaters/duplicate-observed-data-before.png" class="" title="duplicate-observed-data-before">

<p><strong>解决</strong></p>
<p>一个比较好的方法是将负责 GUI 的数据放入一个独立的类，以确保 GUI 数据与域类之间的连接和同步。</p>
<img src="/2020/02/17/bloaters/duplicate-observed-data-after.png" class="" title="duplicate-observed-data-after">

<p>如果想利用单一类做太多事情，其内往往就会出现太多的成员变量。</p>
<blockquote>
<ul>
<li>提取完成同一任务的相关变量到一个新的类。</li>
<li>干太多事情的类，可以考虑把责任委托给其他类。</li>
</ul>
</blockquote>
<p><strong>Tips：一个类如果拥有太多的代码，也是代码重复、混乱、死亡的绝佳滋生地点。</strong></p>
<h2 id="基本类型偏执"><a href="#基本类型偏执" class="headerlink" title="基本类型偏执"></a>基本类型偏执</h2><blockquote>
<ul>
<li>使用基本类型而不是小对象来实现简单任务（例如货币、范围、电话号码字符串等）。</li>
<li>使用常量编码信息（例如一个用于引用管理员权限的常量 USER_ADMIN_ROLE = 1 ）。</li>
<li>使用字符串常量作为字段名在数组中使用。</li>
</ul>
</blockquote>
<img src="/2020/02/17/bloaters/primitive-obsession-01.png" class="" title="primitive-obsession-01">

<h2 id="问题原因-1"><a href="#问题原因-1" class="headerlink" title="问题原因"></a>问题原因</h2><p>类似其他大部分坏味道，基本类型偏执诞生于类初建的时候。一开始，可能只是不多的字段，随着表示的特性越来越多，基本数据类型字段也越来越多。</p>
<p>基本类型常常被用于表示模型的类型。你有一组数字或字符串用来表示某个实体。</p>
<p>还有一个场景：在模拟场景，大量的字符串常量被用于数组的索引。</p>
<h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><img src="/2020/02/17/bloaters/primitive-obsession-02.png" class="" title="primitive-obsession-02">

<p>大多数编程语言都支持基本数据类型和结构类型（类、结构体等）。结构类型允许程序员将基本数据类型组织起来，以代表某一事物的模型。</p>
<p>基本数据类型可以看成是机构类型的积木块。当基本数据类型数量成规模后，将它们有组织地结合起来，可以更方便的管理这些数据。</p>
<ul>
<li>如果你有大量的基本数据类型字段，就有可能将其中部分存在逻辑联系的字段组织起来，形成一个类。更进一步的是，将与这些数据有关联的方法也一并移入类中。为了实现这个目标，可以尝试 <code>以类取代类型码(Replace Type Code with Class)</code> 。</li>
<li>如果基本数据类型字段的值是用于方法的参数，可以使用 <code>引入参数对象(Introduce Parameter Object)</code> 或 <code>保持对象完整(Preserve Whole Object)</code> 。</li>
<li>如果想要替换的数据值是类型码，而它并不影响行为，则可以运用 <code>以类取代类型码(Replace Type Code with Class)</code> 将它替换掉。如果你有与类型码相关的条件表达式，可运用 <code>以子类取代类型码(Replace Type Code with Subclass)</code> 或 <code>以状态/策略模式取代类型码(Replace Type Code with State/Strategy)</code> 加以处理。</li>
<li>如果你发现自己正从数组中挑选数据，可运用 <code>以对象取代数组(Replace Array with Object)</code> 。</li>
</ul>
<h2 id="收益-2"><a href="#收益-2" class="headerlink" title="收益"></a>收益</h2><ul>
<li>多亏了使用对象替代基本数据类型，使得代码变得更加灵活。</li>
<li>代码变得更加易读和更加有组织。特殊数据可以集中进行操作，而不像之前那样分散。不用再猜测这些陌生的常量的意义以及它们为什么在数组中。</li>
<li>更容易发现重复代码。</li>
</ul>
<img src="/2020/02/17/bloaters/primitive-obsession-03.png" class="" title="primitive-obsession-03">

<h2 id="重构方法说明-2"><a href="#重构方法说明-2" class="headerlink" title="重构方法说明"></a>重构方法说明</h2><h3 id="以类取代类型码-Replace-Type-Code-with-Class"><a href="#以类取代类型码-Replace-Type-Code-with-Class" class="headerlink" title="以类取代类型码(Replace Type Code with Class)"></a>以类取代类型码(Replace Type Code with Class)</h3><p><strong>问题</strong></p>
<p>类之中有一个数值类型码，但它并不影响类的行为。</p>
<img src="/2020/02/17/bloaters/replace-type-code-with-class-before.png" class="" title="replace-type-code-with-class-before">

<p><strong>解决</strong></p>
<p>以一个新的类替换该数值类型码。</p>
<img src="/2020/02/17/bloaters/replace-type-code-with-class-after.png" class="" title="replace-type-code-with-class-after">

<h3 id="引入参数对象-Introduce-Parameter-Object-1"><a href="#引入参数对象-Introduce-Parameter-Object-1" class="headerlink" title="引入参数对象(Introduce Parameter Object)"></a>引入参数对象(Introduce Parameter Object)</h3><p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<img src="/2020/02/17/bloaters/introduce-parameter-object-before.png" class="" title="introduce-parameter-object-before">

<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<img src="/2020/02/17/bloaters/introduce-parameter-object-after.png" class="" title="introduce-parameter-object-after">

<h3 id="保持对象完整-Preserve-Whole-Object-1"><a href="#保持对象完整-Preserve-Whole-Object-1" class="headerlink" title="保持对象完整(Preserve Whole Object)"></a>保持对象完整(Preserve Whole Object)</h3><p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int low &#x3D; daysTempRange.getLow();</span><br><span class="line">int high &#x3D; daysTempRange.getHigh();</span><br><span class="line">boolean withinPlan &#x3D; plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean withinPlan &#x3D; plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>

<h3 id="以子类取代类型码-Replace-Type-Code-with-Subclass"><a href="#以子类取代类型码-Replace-Type-Code-with-Subclass" class="headerlink" title="以子类取代类型码(Replace Type Code with Subclass)"></a>以子类取代类型码(Replace Type Code with Subclass)</h3><p><strong>问题</strong></p>
<p>你有一个不可变的类型码，它会影响类的行为。</p>
<img src="/2020/02/17/bloaters/replace-type-code-with-subclasses-before.png" class="" title="replace-type-code-with-subclasses-before">

<p><strong>解决</strong></p>
<p>以子类取代这个类型码。</p>
<img src="/2020/02/17/bloaters/replace-type-code-with-subclasses-after.png" class="" title="replace-type-code-with-subclasses-after">

<h3 id="以状态-策略模式取代类型码-Replace-Type-Code-with-State-Strategy"><a href="#以状态-策略模式取代类型码-Replace-Type-Code-with-State-Strategy" class="headerlink" title="以状态/策略模式取代类型码(Replace Type Code with State/Strategy)"></a>以状态/策略模式取代类型码(Replace Type Code with State/Strategy)</h3><p><strong>问题</strong></p>
<p>你有一个类型码，它会影响类的行为，但你无法通过继承消除它。</p>
<img src="/2020/02/17/bloaters/replace-type-code-with-state-strategy-before.png" class="" title="replace-type-code-with-state-strategy-before">

<p><strong>解决</strong></p>
<p>以状态对象取代类型码。</p>
<img src="/2020/02/17/bloaters/replace-type-code-with-state-strategy-after.png" class="" title="replace-type-code-with-state-strategy-after">

<h3 id="以对象取代数组-Replace-Array-with-Object"><a href="#以对象取代数组-Replace-Array-with-Object" class="headerlink" title="以对象取代数组(Replace Array with Object)"></a>以对象取代数组(Replace Array with Object)</h3><p><strong>问题</strong></p>
<p>你有一个数组，其中的元素各自代表不同的东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] row &#x3D; new String[3];</span><br><span class="line">row[0] &#x3D; &quot;Liverpool&quot;;</span><br><span class="line">row[1] &#x3D; &quot;15&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>以对象替换数组。对于数组中的每个元素，以一个字段来表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Performance row &#x3D; new Performance();</span><br><span class="line">row.setName(&quot;Liverpool&quot;);</span><br><span class="line">row.setWins(&quot;15&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="过长参数列"><a href="#过长参数列" class="headerlink" title="过长参数列"></a>过长参数列</h2><blockquote>
<p>一个函数有超过 3、4 个入参。</p>
</blockquote>
<img src="/2020/02/17/bloaters/long-parameter-list-01.png" class="" title="long-parameter-list-01">

<h3 id="问题原因-2"><a href="#问题原因-2" class="headerlink" title="问题原因"></a>问题原因</h3><p>过长参数列可能是将多个算法并到一个函数中时发生的。函数中的入参可以用来控制最终选用哪个算法去执行。</p>
<p>过长参数列也可能是解耦类之间依赖关系时的副产品。例如，用于创建函数中所需的特定对象的代码已从函数移动到调用函数的代码处，但创建的对象是作为参数传递到函数中。因此，原始类不再知道对象之间的关系，并且依赖性也已经减少。但是如果创建的这些对象，每一个都将需要它自己的参数，这意味着过长参数列。</p>
<p>太长的参数列难以理解，太多参数会造成前后不一致、不易使用，而且一旦需要更多数据，就不得不修改它。</p>
<h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><img src="/2020/02/17/bloaters/long-parameter-list-02.png" class="" title="long-parameter-list-02">

<ul>
<li>如果向已有的对象发出一条请求就可以取代一个参数，那么你应该使用 <code>以函数取代参数(Replace Parameter with Methods)</code> 。在这里，，“已有的对象”可能是函数所属类里的一个字段，也可能是另一个参数。</li>
<li>你还可以运用 <code>保持对象完整(Preserve Whole Object)</code> 将来自同一对象的一堆数据收集起来，并以该对象替换它们。</li>
<li>如果某些数据缺乏合理的对象归属，可使用 <code>引入参数对象(Introduce Parameter Object)</code> 为它们制造出一个“参数对象”。</li>
</ul>
<h3 id="收益-3"><a href="#收益-3" class="headerlink" title="收益"></a>收益</h3><ul>
<li>更易读，更简短的代码。</li>
<li>重构可能会暴露出之前未注意到的重复代码。</li>
</ul>
<h3 id="何时忽略"><a href="#何时忽略" class="headerlink" title="何时忽略"></a>何时忽略</h3><ul>
<li>这里有一个重要的例外：有时候你明显不想造成”被调用对象”与”较大对象”间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情理。但是请注意其所引发的代价。如果参数列太长或变化太频繁，就需要重新考虑自己的依赖结构了。</li>
</ul>
<h3 id="重构方法说明-3"><a href="#重构方法说明-3" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="以函数取代参数-Replace-Parameter-with-Methods"><a href="#以函数取代参数-Replace-Parameter-with-Methods" class="headerlink" title="以函数取代参数(Replace Parameter with Methods)"></a>以函数取代参数(Replace Parameter with Methods)</h4><p><strong>问题</strong></p>
<p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int basePrice &#x3D; quantity * itemPrice;</span><br><span class="line">double seasonDiscount &#x3D; this.getSeasonalDiscount();</span><br><span class="line">double fees &#x3D; this.getFees();</span><br><span class="line">double finalPrice &#x3D; discountedPrice(basePrice, seasonDiscount, fees);</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>让参数接受者去除该项参数，并直接调用前一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int basePrice &#x3D; quantity * itemPrice;</span><br><span class="line">double finalPrice &#x3D; discountedPrice(basePrice);</span><br></pre></td></tr></table></figure>

<h4 id="保持对象完整-Preserve-Whole-Object-2"><a href="#保持对象完整-Preserve-Whole-Object-2" class="headerlink" title="保持对象完整(Preserve Whole Object)"></a>保持对象完整(Preserve Whole Object)</h4><p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int low &#x3D; daysTempRange.getLow();</span><br><span class="line">int high &#x3D; daysTempRange.getHigh();</span><br><span class="line">boolean withinPlan &#x3D; plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean withinPlan &#x3D; plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>

<h4 id="引入参数对象-Introduce-Parameter-Object-2"><a href="#引入参数对象-Introduce-Parameter-Object-2" class="headerlink" title="引入参数对象(Introduce Parameter Object)"></a>引入参数对象(Introduce Parameter Object)</h4><p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<img src="/2020/02/17/bloaters/introduce-parameter-object-before.png" class="" title="introduce-parameter-object-before">

<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<img src="/2020/02/17/bloaters/introduce-parameter-object-after.png" class="" title="introduce-parameter-object-after">

<p>代码中有很多基本数据类型的数据。</p>
<p>Tips:<strong>如果看到一些基本类型数据，尝试定义一种新的数据类型，符合它当前所代表的对象类型。</strong></p>
<h2 id="数据泥团"><a href="#数据泥团" class="headerlink" title="数据泥团"></a>数据泥团</h2><blockquote>
<p>有时，代码的不同部分包含相同的变量组（例如用于连接到数据库的参数）。这些绑在一起出现的数据应该拥有自己的对象。</p>
</blockquote>
<img src="/2020/02/17/bloaters/data-clumps-01.png" class="" title="data-clumps-01">

<h3 id="问题原因-3"><a href="#问题原因-3" class="headerlink" title="问题原因"></a>问题原因</h3><p>通常，数据泥团的出现时因为糟糕的编程结构或“复制-粘贴式编程”。</p>
<p>有一个判断是否是数据泥团的好办法：删掉众多数据中的一项。这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是个明确的信号：你应该为它们产生一个新的对象。</p>
<h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>首先找出这些数据以字段形式出现的地方，运用 <code>提炼类(Extract Class)</code> 将它们提炼到一个独立对象中。</li>
<li>如果数据泥团在函数的参数列中出现，运用 <code>引入参数对象(Introduce Parameter Object)</code> 将它们组织成一个类。</li>
<li>如果数据泥团的部分数据出现在其他函数中，考虑运用 <code>保持对象完整(Preserve Whole Object)</code> 将整个数据对象传入到函数中。</li>
<li>检视一下使用这些字段的代码，也许，将它们移入一个数据类是个不错的主意。</li>
</ul>
<img src="/2020/02/17/bloaters/data-clumps-02.png" class="" title="data-clumps-02">

<h3 id="收益-4"><a href="#收益-4" class="headerlink" title="收益"></a>收益</h3><ul>
<li>提高代码易读性和组织性。对于特殊数据的操作，可以集中进行处理，而不像以前那样分散。</li>
<li>减少代码量。</li>
</ul>
<img src="/2020/02/17/bloaters/data-clumps-03.png" class="" title="data-clumps-03">

<h3 id="何时忽略-1"><a href="#何时忽略-1" class="headerlink" title="何时忽略"></a>何时忽略</h3><ul>
<li>有时为了对象中的部分数据而将整个对象作为参数传递给函数，可能会产生让两个类之间不收欢迎的依赖关系，这中情况下可以不传递整个对象。</li>
</ul>
<h3 id="重构方法说明-4"><a href="#重构方法说明-4" class="headerlink" title="重构方法说明"></a>重构方法说明</h3><h4 id="提炼类-Extract-Class-1"><a href="#提炼类-Extract-Class-1" class="headerlink" title="提炼类(Extract Class)"></a>提炼类(Extract Class)</h4><p><strong>问题</strong></p>
<p>某个类做了不止一件事。</p>
<img src="/2020/02/17/bloaters/extract-class-before.png" class="" title="extract-class-before">

<p><strong>解决</strong></p>
<p>建立一个新类，将相关的字段和函数从旧类搬移到新类。</p>
<img src="/2020/02/17/bloaters/extract-class-after.png" class="" title="extract-class-after">

<h4 id="引入参数对象-Introduce-Parameter-Object-3"><a href="#引入参数对象-Introduce-Parameter-Object-3" class="headerlink" title="引入参数对象(Introduce Parameter Object)"></a>引入参数对象(Introduce Parameter Object)</h4><p><strong>问题</strong></p>
<p>某些参数总是很自然地同时出现。</p>
<img src="/2020/02/17/bloaters/introduce-parameter-object-before.png" class="" title="introduce-parameter-object-before">

<p><strong>解决</strong></p>
<p>以一个对象来取代这些参数。</p>
<img src="/2020/02/17/bloaters/introduce-parameter-object-after.png" class="" title="introduce-parameter-object-after">

<h4 id="保持对象完整-Preserve-Whole-Object-3"><a href="#保持对象完整-Preserve-Whole-Object-3" class="headerlink" title="保持对象完整(Preserve Whole Object)"></a>保持对象完整(Preserve Whole Object)</h4><p><strong>问题</strong></p>
<p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int low &#x3D; daysTempRange.getLow();</span><br><span class="line">int high &#x3D; daysTempRange.getHigh();</span><br><span class="line">boolean withinPlan &#x3D; plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<p>改为传递整个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean withinPlan &#x3D; plan.withinRange(daysTempRange);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/17/bloaters/" data-id="ck6pz1tzu00001j2v5nrtb59p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/refactor/" rel="tag">refactor</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-automated-test-summary" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/16/android-automated-test-summary/" class="article-date">
  <time datetime="2020-02-16T13:28:12.000Z" itemprop="datePublished">2020-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/16/android-automated-test-summary/">Android自动化测试总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android自动化测试总结"><a href="#Android自动化测试总结" class="headerlink" title="Android自动化测试总结"></a>Android自动化测试总结</h1><h2 id="测试金字塔"><a href="#测试金字塔" class="headerlink" title="测试金字塔"></a>测试金字塔</h2><img src="/2020/02/16/android-automated-test-summary/of-tests.png" class="" title="测试金字塔，显示了应用的测试套件应包含的三类测试">

<p>沿着金字塔逐级向上，从小型测试到大型测试，各类测试的保真度逐级提高，但维护和调试工作所需的执行时间和工作量也逐级增加。因此，您编写的单元测试应多于集成测试，集成测试应多于端到端测试。虽然各类测试的比例可能会因应用的用例不同而异，但我们通常建议各类测试所占比例如下：<strong>小型测试占70%，中型测试占20%，大型测试占10%</strong>。</p>
<h2 id="单元测试（小型测试）"><a href="#单元测试（小型测试）" class="headerlink" title="单元测试（小型测试）"></a>单元测试（小型测试）</h2><p><strong>用于验证应用的行为，一次验证一个类。</strong></p>
<p><strong>原则（<code>F.I.R.S.T</code>）</strong></p>
<p><strong>F</strong>ast(快)，单元测试要运行的足够快，单个测试方法一般要立即（一秒之内）给出结果。<br><strong>I</strong>dependent(独立)，测试方法之间不要有依赖（先执行某个测试方法，再执行另一个测试方法才能通过）。<br><strong>R</strong>epeatable（重复），可以在本地或 CI 不同环境（机器上）上反复执行，不会出现不稳定的情况。<br><strong>S</strong>elf-Validating（自验证），单元测试必须包含足够多的断言进行自我验证。<br><strong>T</strong>imely（及时），理想情况下应测试先行，至少保证单元测试应该和实现代码一起及时完成并提交。</p>
<p>除此之外，测试代码应该具备最好的<strong>可读性</strong>和最少的<strong>维护代价</strong>，绝大多数情况下写测试应该就像用<strong>领域特定语言描述一个事实</strong>，甚至<strong>不用经过仔细地思考</strong>。</p>
<h3 id="构建本地单元测试"><a href="#构建本地单元测试" class="headerlink" title="构建本地单元测试"></a>构建本地单元测试</h3><p><strong>当需要更快地运行测试而不需要与在真实设备上运行测试关联的保真度和置信度时，可以使用本地单元测试来验证应用的逻辑。</strong></p>
<ul>
<li>如果测试对<code>Android</code>框架有依赖性（特别是与框架建立复杂交互的测试），则最好使用 <code>Robolectric</code>添加框架依赖项。</li>
</ul>
<blockquote>
<p>例：待测试的类同时依赖<code>Context</code>、<code>Intent</code>、<code>Bundle</code>、<code>Application</code>等<code>Android Framework</code>中的类时，此时我们可以引入<code>Robolectric</code>框架进行本地单元测试的编写。</p>
</blockquote>
<ul>
<li>如果测试对<code>Android</code>框架的依赖性极小，或者如果测试仅取决于我们自己应用的对象，则可以使用诸如<code>Mockito</code>之类的模拟框架添加模拟依赖项。(<a href="https://github.com/android/testing-samples/tree/master/unit/BasicUnitAndroidTest" target="_blank" rel="noopener">BasicUnitAndroidTest</a>)</li>
</ul>
<blockquote>
<p>例：待测试的类只依赖<code>java api</code>（最理想的情况）,此时对于待测试类所依赖的其他类我们就可以利用<code>Mockito</code>框架mock其依赖类，再进行当前类的单元测试编写。(<a href="https://github.com/android/testing-samples/blob/master/unit/BasicSample/app/src/test/java/com/example/android/testing/unittesting/BasicSample/EmailValidatorTest.java" target="_blank" rel="noopener">EmailValidatorTest</a>)</p>
</blockquote>
<blockquote>
<p>例：待测试的类除了依赖<code>java api</code>外仅依赖<code>Android Framework</code>中<code>Context</code>这个类,此时我们就可以利用<code>Mockito</code>框架<code>mock</code> <code>Context</code>类，再进行当前类的单元测试编写。(<a href="https://github.com/android/testing-samples/blob/master/unit/BasicSample/app/src/test/java/com/example/android/testing/unittesting/BasicSample/SharedPreferencesHelperTest.java" target="_blank" rel="noopener">SharedPreferencesHelperTest</a>) </p>
</blockquote>
<h4 id="设置测试环境"><a href="#设置测试环境" class="headerlink" title="设置测试环境"></a>设置测试环境</h4><p>在<code>Android Studio</code>项目中，本地单元测试的源文件存储在<code>module-name/src/test/java/</code>中。</p>
<p>在模块的顶级<code>build.gradle</code>文件中，将以下库指定为依赖项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    &#x2F;&#x2F; Required -- JUnit 4 framework</span><br><span class="line">    testImplementation &quot;junit:junit:$junitVersion&quot;</span><br><span class="line">    &#x2F;&#x2F; Optional -- Mockito framework</span><br><span class="line">    testImplementation &quot;org.mockito:mockito-core:$mockitoCoreVersion&quot;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Optional -- Robolectric environment</span><br><span class="line">   testImplementation &quot;androidx.test:core:$xcoreVersion&quot;</span><br><span class="line">   testImplementation &quot;androidx.test.ext:junit:$extJunitVersion&quot;</span><br><span class="line">   testImplementation &quot;org.robolectric:robolectric:$robolectricVersion&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果单元测试依赖于资源，需要在module的build.gradle文件中启用<code>includeAndroidResources</code>选项。然后，单元测试可以访问编译版本的资源，从而使测试更快速且更准确地运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    testOptions &#123;</span><br><span class="line">        unitTests &#123;</span><br><span class="line">            includeAndroidResources &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">@Config(manifest &#x3D; Config.NONE)</span><br><span class="line">class PeopleDaoTest &#123;</span><br><span class="line">    private lateinit var database: PeopleDatabase</span><br><span class="line"></span><br><span class="line">    private lateinit var peopleDao: PeopleDao</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    fun &#96;create db&#96;() &#123;</span><br><span class="line">        database &#x3D; Room.inMemoryDatabaseBuilder(</span><br><span class="line">            ApplicationProvider.getApplicationContext(),</span><br><span class="line">            PeopleDatabase::class.java</span><br><span class="line">        ).allowMainThreadQueries().build()</span><br><span class="line"></span><br><span class="line">        peopleDao &#x3D; database.peopleDao()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    fun &#96;should return empty list when getPeople without inserted data&#96;() &#123;</span><br><span class="line">        val result &#x3D; peopleDao.getPeople(pageId &#x3D; 1)</span><br><span class="line"></span><br><span class="line">        assertThat(result).isNotNull()</span><br><span class="line">        assertThat(result).isEmpty()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果单元测试包含异步操作时，可以使用<a href="https://github.com/awaitility/awaitility" target="_blank" rel="noopener">awaitility库</a>进行测试；当使用<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a>响应式编程库时，可以自定义rule：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class RxJavaRule : TestWatcher() &#123;</span><br><span class="line">    override fun starting(description: Description?) &#123;</span><br><span class="line">        super.starting(description)</span><br><span class="line"></span><br><span class="line">        RxJavaPlugins.setIoSchedulerHandler &#123;</span><br><span class="line">            Schedulers.trampoline()</span><br><span class="line">        &#125;</span><br><span class="line">        RxJavaPlugins.setNewThreadSchedulerHandler &#123;</span><br><span class="line">            Schedulers.trampoline()</span><br><span class="line">        &#125;</span><br><span class="line">        RxJavaPlugins.setComputationSchedulerHandler &#123;</span><br><span class="line">            Schedulers.trampoline()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RxAndroidPlugins.setMainThreadSchedulerHandler &#123;</span><br><span class="line">            Schedulers.trampoline()</span><br><span class="line">        &#125;</span><br><span class="line">        RxAndroidPlugins.setInitMainThreadSchedulerHandler &#123;</span><br><span class="line">            Schedulers.trampoline()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun finished(description: Description?) &#123;</span><br><span class="line">        super.finished(description)</span><br><span class="line"></span><br><span class="line">        RxJavaPlugins.reset()</span><br><span class="line"></span><br><span class="line">        RxAndroidPlugins.reset()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TestScheduler</code>中<code>triggerActions</code>的使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(JUnit4::class)</span><br><span class="line">class FilmViewModelTest &#123;</span><br><span class="line">    @get:Rule</span><br><span class="line">    val instantTaskExecutorRule &#x3D; InstantTaskExecutorRule()</span><br><span class="line">    @get:Rule</span><br><span class="line">    val rxJavaRule &#x3D; RxJavaRule()</span><br><span class="line"></span><br><span class="line">    private val repository &#x3D; mock(Repository::class.java)</span><br><span class="line"></span><br><span class="line">    private val testScheduler &#x3D; TestScheduler()</span><br><span class="line"></span><br><span class="line">    private lateinit var viewModel: FilmViewModel</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    fun init() &#123;</span><br><span class="line">        viewModel &#x3D; FilmViewModel(repository)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    fun &#96;should return true when loadFilms is loading&#96;() &#123;</span><br><span class="line">        &#96;when&#96;(repository.getPopularFilms(1)).thenReturn(</span><br><span class="line">            Single.just(emptyList&lt;Film&gt;())</span><br><span class="line">                .subscribeOn(testScheduler)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        viewModel.loadFilms(0)</span><br><span class="line"></span><br><span class="line">        assertThat(getValue(viewModel.isLoading)).isTrue()</span><br><span class="line">        testScheduler.triggerActions()</span><br><span class="line">        assertThat(getValue(viewModel.isLoading)).isFalse()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    fun &#96;should return films list when loadFilms successful&#96;() &#123;</span><br><span class="line">        &#96;when&#96;(repository.getPopularFilms(1)).thenReturn(</span><br><span class="line">            Single.just(</span><br><span class="line">                listOf(</span><br><span class="line">                    Film(123, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, 1)</span><br><span class="line">                )</span><br><span class="line">            ).subscribeOn(testScheduler)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        viewModel.loadFilms(0)</span><br><span class="line"></span><br><span class="line">        assertThat(getValue(viewModel.films)).isNull()</span><br><span class="line">        testScheduler.triggerActions()</span><br><span class="line">        assertThat(getValue(viewModel.films)).isNotNull()</span><br><span class="line">        assertThat(getValue(viewModel.films).size).isEqualTo(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TestSubscriber</code>的使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(JUnit4::class)</span><br><span class="line">class WebServiceTest &#123;</span><br><span class="line">    private lateinit var webService: WebService</span><br><span class="line"></span><br><span class="line">    private lateinit var mockWebServer: MockWebServer</span><br><span class="line"></span><br><span class="line">    @get:Rule</span><br><span class="line">    val instantExecutorRule &#x3D; InstantTaskExecutorRule()</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    fun &#96;start service&#96;() &#123;</span><br><span class="line">        mockWebServer &#x3D; MockWebServer()</span><br><span class="line"></span><br><span class="line">        webService &#x3D; Retrofit.Builder()</span><br><span class="line">            .baseUrl(mockWebServer.url(&quot;&#x2F;&quot;))</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">            .build()</span><br><span class="line">            .create(WebService::class.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    fun &#96;should return fim list when getFilms successful&#96;() &#123;</span><br><span class="line">        assertThat(webService).isNotNull()</span><br><span class="line"></span><br><span class="line">        enqueueResponse(&quot;popular_films.json&quot;)</span><br><span class="line"></span><br><span class="line">        val testObserver &#x3D; webService.getPopularFilms(page &#x3D; 1)</span><br><span class="line">            .map &#123;</span><br><span class="line">                it.data</span><br><span class="line">            &#125;.test()</span><br><span class="line"></span><br><span class="line">        testObserver.assertNoErrors()</span><br><span class="line">        testObserver.assertValueCount(1)</span><br><span class="line">        testObserver.assertValue &#123;</span><br><span class="line">            assertThat(it).isNotEmpty()</span><br><span class="line">            assertThat(it[0].id).isEqualTo(297761)</span><br><span class="line">            assertThat(it[1].id).isEqualTo(324668)</span><br><span class="line">            it.size &#x3D;&#x3D; 2</span><br><span class="line">        &#125;</span><br><span class="line">        testObserver.assertComplete()</span><br><span class="line">        testObserver.dispose()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After</span><br><span class="line">    fun &#96;stop service&#96;() &#123;</span><br><span class="line">        mockWebServer.shutdown()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun enqueueResponse(fileName: String) &#123;</span><br><span class="line">        val inputStream &#x3D; javaClass.classLoader?.getResourceAsStream(&quot;api-response&#x2F;$fileName&quot;)</span><br><span class="line">            ?: return</span><br><span class="line">        val source &#x3D; inputStream.source().buffer()</span><br><span class="line">        val mockResponse &#x3D; MockResponse()</span><br><span class="line">        mockWebServer.enqueue(</span><br><span class="line">            mockResponse</span><br><span class="line">                .setBody(source.readString(Charsets.UTF_8))</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建插桩单元测试"><a href="#构建插桩单元测试" class="headerlink" title="构建插桩单元测试"></a>构建插桩单元测试</h3><p><strong>插桩单元测试是在物理设备和模拟器上运行的测试，此类测试可以利用<code>Android</code>框架<code>API</code>。插桩测试提供的保真度比本地单元测试要高，但运行速度要慢得多。因此，我们建议只有在必须针对真实设备的行为进行测试时才使用插桩单元测试。</strong></p>
<h4 id="设置测试环境-1"><a href="#设置测试环境-1" class="headerlink" title="设置测试环境"></a>设置测试环境</h4><p>在<code>Android Studio</code>项目中，插桩测试的源文件存储在<code>module-name/src/androidTest/java/</code>。</p>
<p>在模块的顶级<code>build.gradle</code>文件中，将以下库指定为依赖项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    androidTestImplementation &quot;androidx.test.ext:junit:$extJunitVersion&quot;</span><br><span class="line">    androidTestImplementation &quot;androidx.test:core:$xcoreVersion&quot;</span><br><span class="line">    androidTestImplementation &quot;androidx.test:rules:$rulesVersion&quot;</span><br><span class="line">    &#x2F;&#x2F; Optional -- Truth library</span><br><span class="line">    androidTestImplementation &quot;androidx.test.ext:truth:$androidxtruthVersion&quot;</span><br><span class="line">    androidTestImplementation &quot;org.mockito:mockito-core:$mockitoCoreVersion&quot;</span><br><span class="line">    androidTestImplementation &quot;org.mockito:mockito-android:$mockitoAndroidVersion&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(AndroidJUnit4::class)</span><br><span class="line">@SmallTest</span><br><span class="line">class FilmDaoTest &#123;</span><br><span class="line">    @get:Rule</span><br><span class="line">    var instantTaskExecutorRule &#x3D; InstantTaskExecutorRule()</span><br><span class="line"></span><br><span class="line">    private lateinit var database: FilmDatabase</span><br><span class="line"></span><br><span class="line">    private lateinit var filmDao: FilmDao</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    fun initDb() &#123;</span><br><span class="line">        database &#x3D; Room.inMemoryDatabaseBuilder(</span><br><span class="line">            ApplicationProvider.getApplicationContext(),</span><br><span class="line">            FilmDatabase::class.java</span><br><span class="line">        ).build()</span><br><span class="line"></span><br><span class="line">        filmDao &#x3D; database.filmData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    fun should_return_film_list_when_getFilms_with_inserted_film_list() &#123;</span><br><span class="line">        filmDao.insert(</span><br><span class="line">            Film(100, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, 1)</span><br><span class="line">        )</span><br><span class="line">        filmDao.insert(</span><br><span class="line">            Film(101, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, 1)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        val result &#x3D; filmDao.getFilms(1)</span><br><span class="line"></span><br><span class="line">        assertThat(result).isNotNull()</span><br><span class="line">        assertThat(result).isNotEmpty()</span><br><span class="line">        assertThat(result.size).isEqualTo(2)</span><br><span class="line">        assertThat(result[0].id).isEqualTo(100)</span><br><span class="line">        assertThat(result[0].page).isEqualTo(1)</span><br><span class="line">        assertThat(result[1].id).isEqualTo(101)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    fun should_return_film_list_with_size_1_when_getFilms_with_inserted_2_same_film() &#123;</span><br><span class="line">        filmDao.insert(</span><br><span class="line">            Film(100, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, 1)</span><br><span class="line">        )</span><br><span class="line">        filmDao.insert(</span><br><span class="line">            Film(100, &quot;1223&quot;, &quot;111&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, 1)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        val result &#x3D; filmDao.getFilms(1)</span><br><span class="line"></span><br><span class="line">        assertThat(result).isNotNull()</span><br><span class="line">        assertThat(result).isNotEmpty()</span><br><span class="line">        assertThat(result.size).isEqualTo(1)</span><br><span class="line">        assertThat(result[0].id).isEqualTo(100)</span><br><span class="line">        assertThat(result[0].page).isEqualTo(1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    fun should_return_empty_list_when_getFilms_with_deleteAll_called() &#123;</span><br><span class="line">        filmDao.insert(</span><br><span class="line">            Film(100, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, 1)</span><br><span class="line">        )</span><br><span class="line">        filmDao.deleteAll()</span><br><span class="line"></span><br><span class="line">        val newResult &#x3D; filmDao.getFilms(1)</span><br><span class="line"></span><br><span class="line">        assertThat(newResult).isNotNull()</span><br><span class="line">        assertThat(newResult).isEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After</span><br><span class="line">    fun closeDb() &#x3D; database.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<ul>
<li><p>基于目前流行的<code>MVP</code>、<code>MVVM</code>架构设计模式，<code>MVP</code>中<code>Model</code>层和<code>Presenter</code>层尽量不依赖<code>Android Framework</code>，<code>MVVM</code>中<code>Model</code>层和<code>ViewModel</code>层尽量不依赖<code>Android Framework</code>。</p>
</li>
<li><p>类的设计做到单一职责原则,依赖其他类时提供方便mock的方式（例如作为构造方法参数传递），某一个方法依赖其他对象时，小重构该对象作为方法参数传入。</p>
</li>
<li><p>方法尽量短小（方法太长时可以利用重构手法在方法中再提取方法）。</p>
</li>
<li><p>只覆盖public方法单元测试，privite方法可以间接测试。</p>
</li>
<li><p>当依赖<code>Android Framework API</code>非常少时，可以采用<code>Mock Android api</code>的方式。</p>
</li>
<li><p>当严重依赖<code>Android Framework API</code>时，引入<code>Robolectric</code>库模拟<code>Android</code>环境或者放入AndroidTest目录作为插桩单元测试在物理设备上跑。</p>
</li>
<li><p>使用<code>Robolectric</code>库写本地单元测试时，依赖的某些类的方法调用出问题导致测试<code>failed</code>时，可以使用<code>shadow</code>类提供默认实现。</p>
</li>
<li><p>每条测试采用<code>Given</code>、<code>When</code>、<code>Then</code>的方式进行区分.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void should_do_something_if_some_condition_fulfills() &#123;</span><br><span class="line">    &#x2F;&#x2F; Given 设置前置条件</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; When 执行被测方法</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Then 验证方法结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="集成测试（中型测试）"><a href="#集成测试（中型测试）" class="headerlink" title="集成测试（中型测试）"></a>集成测试（中型测试）</h2><p><strong>用于验证模块内堆栈级别之间的交互或相关模块之间的交互</strong></p>
<ul>
<li>如果应用使用了用户不直接与之交互的组件（如<code>Service</code>或<code>ContentProvider</code>），应验证这些组件在应用中的行为是否正确。</li>
</ul>
<h3 id="设置测试环境-2"><a href="#设置测试环境-2" class="headerlink" title="设置测试环境"></a>设置测试环境</h3><p><strong>参考插桩单元测试环境设置</strong></p>
<h4 id="Service测试"><a href="#Service测试" class="headerlink" title="Service测试"></a>Service测试</h4><ul>
<li><strong>利用<code>ServiceTestRule</code>，可在单元测试方法运行之前启动服务，并在测试完成后关闭服务。</strong></li>
<li><strong><code>ServiceTestRule</code>类不支持测试<code>IntentService</code>对象。如果需要测试<code>IntentService</code>对象，可以应将逻辑封装在一个单独的类中，并创建相应的单元测试。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@MediumTest</span><br><span class="line">@RunWith(AndroidJUnit4.class)</span><br><span class="line">public class LocalServiceTest &#123;</span><br><span class="line">    @Rule</span><br><span class="line">    public final ServiceTestRule mServiceRule &#x3D; new ServiceTestRule();</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testWithBoundService() throws TimeoutException &#123;</span><br><span class="line">        &#x2F;&#x2F; Create the service Intent.</span><br><span class="line">        Intent serviceIntent &#x3D;</span><br><span class="line">                new Intent(getApplicationContext(), LocalService.class);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Data can be passed to the service via the Intent.</span><br><span class="line">        serviceIntent.putExtra(LocalService.SEED_KEY, 42L);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Bind the service and grab a reference to the binder.</span><br><span class="line">        IBinder binder &#x3D; mServiceRule.bindService(serviceIntent);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Get the reference to the service, or you can call public methods on the binder directly.</span><br><span class="line">        LocalService service &#x3D; ((LocalService.LocalBinder) binder).getService();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Verify that the service is working correctly.</span><br><span class="line">        assertThat(service.getRandomInt(), is(any(Integer.class)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ContentProvider的测试"><a href="#ContentProvider的测试" class="headerlink" title="ContentProvider的测试"></a>ContentProvider的测试</h4><p><strong>使用<code>ProviderTestRule</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Rule</span><br><span class="line">public ProviderTestRule mProviderRule &#x3D;</span><br><span class="line">    new ProviderTestRule.Builder(MyContentProvider.class, MyContentProvider.AUTHORITY).build();</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void verifyContentProviderContractWorks() &#123;</span><br><span class="line">    ContentResolver resolver &#x3D; mProviderRule.getResolver();</span><br><span class="line">    &#x2F;&#x2F; perform some database (or other) operations</span><br><span class="line">    Uri uri &#x3D; resolver.insert(testUrl, testContentValues);</span><br><span class="line">    &#x2F;&#x2F; perform some assertions on the resulting URI</span><br><span class="line">    assertNotNull(uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Rule</span><br><span class="line">public ProviderTestRule mProviderRule &#x3D;</span><br><span class="line">    new ProviderTestRule.Builder(MyContentProvider.class, MyContentProvider.AUTHORITY)</span><br><span class="line">        .setDatabaseCommands(DATABASE_NAME, INSERT_ONE_ENTRY_CMD, INSERT_ANOTHER_ENTRY_CMD)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void verifyTwoEntriesInserted() &#123;</span><br><span class="line">    ContentResolver mResolver &#x3D; mProviderRule.getResolver();</span><br><span class="line">    &#x2F;&#x2F; two entries are already inserted by rule, we can directly perform assertions to verify</span><br><span class="line">    Cursor c &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">      c &#x3D; mResolver.query(URI_TO_QUERY_ALL, null, null, null, null);</span><br><span class="line">      assertNotNull(c);</span><br><span class="line">      assertEquals(2, c.getCount());</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (c !&#x3D; null &amp;&amp; !c.isClosed()) &#123;</span><br><span class="line">        c.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Android</code>没有为<code>BroadcastReceiver</code>提供单独的测试用例类。要验证 <code>BroadcastReceiver</code>是否正确响应，可以测试向其发送<code>Intent</code>对象的组件。或者，可以通过调用<code>ApplicationProvider.getApplicationContext()</code>来创建<code>BroadcastReceiver</code>的实例，然后调用要测试的<code>BroadcastReceiver</code>方法（通常是<code>onReceive()</code>方法）。</li>
</ul>
<h2 id="端到端测试（大型测试）"><a href="#端到端测试（大型测试）" class="headerlink" title="端到端测试（大型测试）"></a>端到端测试（大型测试）</h2><p><strong>用于验证跨越了应用的多个模块的用户操作流程</strong></p>
<p><strong>界面测试的一种方法是直接让测试人员对目标应用执行一系列用户操作，并验证其行为是否正常。不过，这种人工方法会非常耗时、繁琐且容易出错。一种更高效的方法是编写界面测试，以便以自动化方式执行用户操作。自动化方法可以以可重复的方式快速可靠地运行测试。</strong></p>
<h3 id="设置测试环境-3"><a href="#设置测试环境-3" class="headerlink" title="设置测试环境"></a>设置测试环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    androidTestImplementation &quot;androidx.test.ext:junit:$extJunitVersion&quot;</span><br><span class="line">    androidTestImplementation &quot;androidx.test:core:$xcoreVersion&quot;</span><br><span class="line">    androidTestImplementation &quot;androidx.test:rules:$rulesVersion&quot;</span><br><span class="line">    &#x2F;&#x2F; Optional -- Truth library</span><br><span class="line">    androidTestImplementation &quot;androidx.test.ext:truth:$androidxtruthVersion&quot;</span><br><span class="line">    androidTestImplementation &quot;org.mockito:mockito-core:$mockitoCoreVersion&quot;</span><br><span class="line">    androidTestImplementation &quot;org.mockito:mockito-android:$mockitoAndroidVersion&quot;</span><br><span class="line">     &#x2F;&#x2F; Optional -- UI testing with Espresso</span><br><span class="line">    androidTestImplementation &quot;androidx.test.espresso:espresso-core:$espressoVersion&quot;</span><br><span class="line">    androidTestImplementation &quot;androidx.test.espresso:espresso-intents:$espressoVersion&quot;</span><br><span class="line">    &#x2F;&#x2F; Optional -- UI testing with UI Automator</span><br><span class="line">    androidTestImplementation &quot;androidx.test.uiautomator:uiautomator:$uiautomatorVersion&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>涵盖单个应用的界面测试</strong>：这种类型的测试可验证目标应用在用户执行特定操作或在其 <code>Activity</code> 中输入特定内容时的行为是否符合预期。它可让您检查目标应用是否返回正确的界面输出来响应应用 <code>Activity</code> 中的用户交互。诸如 <code>Espresso</code> 之类的界面测试框架可让您以编程方式模拟用户操作，并测试复杂的应用内用户交互。(<a href="https://github.com/android/testing-samples/tree/master/ui/espresso" target="_blank" rel="noopener">espresso测试单个应用的界面例子</a>)</p>
</li>
<li><p><strong>涵盖多个应用的界面测试</strong>：这种类型的测试可验证不同用户应用之间交互或用户应用与系统应用之间交互的正确行为。例如，您可能想要测试相机应用是否能够与第三方社交媒体应用或默认的 <code>Android</code> 相册应用正确分享图片。支持跨应用交互的界面测试框架（如 <code>UI Automator</code>）可让您针对此类场景创建测试。（<a href="https://github.com/android/testing-samples/tree/master/ui/uiautomator/BasicSample" target="_blank" rel="noopener">uiautomator测试多个应用的界面</a>）</p>
</li>
</ul>
<p><a href="https://github.com/android/testing-samples" target="_blank" rel="noopener">参考例子testing-samples</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/16/android-automated-test-summary/" data-id="ck6pz1u0300011j2v44f3dppi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/test/" rel="tag">test</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/refactor/" rel="tag">refactor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/refactor/" style="font-size: 10px;">refactor</a> <a href="/tags/test/" style="font-size: 10px;">test</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/17/bloaters/">代码坏味道之膨胀剂</a>
          </li>
        
          <li>
            <a href="/2020/02/16/android-automated-test-summary/">Android自动化测试总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 komamj<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>